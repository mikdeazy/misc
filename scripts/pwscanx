#!/usr/bin/env python
#
# Electrum password scanner (multi-processing)
#

import sys, time, base64, hashlib, multiprocessing
from Crypto.Cipher import AES

wildchar = '?'
wildcode = '\0'
pwd_grps = {'u': 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'l':'abcdefghijklmnopqrstuvwxyz', 'n':'0123456789', 
           'a':'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz', 's':'!?#@$%&*()+-~<>.,:;' }
pwd_chars = pwd_grps['a']+pwd_grps['n']+pwd_grps['s']

def wild_charset(pwd):
    p = pwd.find(wildcode)
    if p+1 == len(pwd) or pwd[p+1] != ':':
        return p,pwd_chars,1
    cs,l = '',2
    while(pwd[p+l] in pwd_grps.keys()):
        cs += pwd_grps[pwd[p+l]]
        l += 1
    return p,cs,l+1

def sha256(x):
    return hashlib.sha256(x).digest()
    
def test(pwd):
    try:
        the_xprv = AES.new(sha256(sha256(pwd)), AES.MODE_CBC, xprv[:16]).decrypt(xprv[16:32]).decode("utf8")
    except Exception:
        pass
    else:
        if the_xprv[:4] == "xprv":
            the_xprv = AES.new(sha256(sha256(pwd)), AES.MODE_CBC, xprv[:16]).decrypt(xprv[16:]).decode("utf8")
            print "\nPWD:", pwd
            print "XPRV:", the_xprv[:-ord(the_xprv[-1])]
            print "Took %.1f seconds" % (time.time() - started,)
            sys.exit(2)
    
def subproc(pwd):
    if pwd.count(wildcode) == 0:
        test(pwd)
    elif pwd.count(wildcode) == 1:
        p,cs,l = wild_charset(pwd)
        for c in cs:
            test(pwd[:p]+c+pwd[p+l:])
    else:
        p,cs,l = wild_charset(pwd)
        for c in cs:
            subproc(pwd[:p]+c+pwd[p+l:])
    
def pwd_sub(pwd):
    global done, procs
    if len(procs) == max_procs:
        for p in procs:
            p.join()
            if p.exitcode == 2:
                done = True
        procs = []
    if not done:
        if pwd.count(wildcode) <= 2:
            proc = multiprocessing.Process(target = subproc, args = (pwd,))
            procs.append(proc)
            proc.start()
        else:
            p,cs,l = wild_charset(pwd)
            for c in cs:
                pwd_sub(pwd[:p]+c+pwd[p+l:])

def tokproc(pwd):
    for token in tokens:
        subproc(pwd+token)
            
def pwd_tok(pwd, depth):
    global done, procs
    if len(procs) == max_procs:
        for p in procs:
            p.join()
            if p.exitcode == 2:
                done = True
        procs = []
    if not done:
        if depth == 0:
            proc = multiprocessing.Process(target = tokproc, args = (pwd,))
            procs.append(proc)
            proc.start()
        else:
            for token in tokens:
                pwd_tok(pwd+token, depth-1)

if __name__ == '__main__':
    
    max_procs = multiprocessing.cpu_count()
    procs = []
    done = False
    
    if len(sys.argv) < 3:
        print "Electrum wallet password scanner (multiprocessing)"
        print "Default wild char is: %s" % wildchar
        print "Default charset is: %s" % pwd_chars
        print "Example template: myPwd%s%s123" % (wildchar,wildchar)
        print "\n@ template prefix means load templates (one per line) from file and scan each"
        print "If charset provided then first char is wild char; if - then value skipped and default is used"  
        print "If depth is provided then templates from file are used as tokens combined to that depth"
        print "Tokens can contain wild chars but when combined will greatly increase search time"
        print "A wild char followed by ':' uses char groups, ':' ends, where:"
        print "\tu=upper case, l=lowercase, a=alpha (u+l), n=numeric, s=symbols"
        print "\teg. myPwd%s:ls:123 scans only lower case and symbols" % wildchar
        print "\nUsage: %s <pwd template> <xprv from wallet file> [charset] [depth]\n" % sys.argv[0]
        sys.exit(0)
        
    if sys.argv[1][0] != '@' and sys.argv[1].count(wildchar) == 0:
        print "Need at least one %s in template" % wildchar
        sys.exit(0)
        
    if len(sys.argv) > 3 and sys.argv[3][0] != '-':
        wildchar = sys.argv[3][0]
        pwd_chars = sys.argv[3][1:]
        
    depth = int(sys.argv[4]) if len(sys.argv) > 4 else 0        
        
    xprv = base64.b64decode(sys.argv[2])
    started = time.time()
    
    if sys.argv[1][0] != '@':
        pwd_sub(sys.argv[1].replace(wildchar, wildcode))
    else:
        tokens = [ line.strip().replace(wildchar, wildcode) for line in open(sys.argv[1][1:]) if not line.strip() == '']
        if depth == 0:
            for t in tokens:
                print "Checking", t
                pwd_sub(t)
        else:
            for n in range(depth):
                pwd_tok("", n)
    
    for p in procs:
        p.join()
        if p.exitcode == 2:
            done = True
                            
    if not done:
        print "Password not found"


    




